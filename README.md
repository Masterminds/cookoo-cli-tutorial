# 3. Hello You

In this chapter we're going to take a jump in complexity. We're adding
two things to our program:

- Real help text
- Command-line flags

Before diving into this chapter, take a quick look at `main.go`. Pay
special attention to the FlagSet, the revised Route, and the last line
of the `main()` function.

## Help Text

The Cookoo CLI runner has built-in support for generating application
help. We've been mostly ignoring the help text, but in this chapter
we'll see how to use it correctly.

**Note:** While supplying help text is optional, it is *highly*
recommended.

In this chapter's version of `main.go`, you'll notice two new `const`
declrations:

```go
const (
	Summary = "A Hello World program"
	Description = `This program writes Hello World to standard output.

With the -a flag, the second word can be replaced by an artitary string.
`
)
```

These are the two big pieces of help text for the program. In a moment,
we will see how they get passed into the `Help()` function. Note,
though, that `Description` is multi-line. That is normal. `Summary`
should be short (160 characters or less), which `Description` may be
several paragraphs long, if necessary.

## Flags

Also new in this chapter's `main.go` is an explicit declaration of a set
of flags:

```go
	flags := flag.NewFlagSet("global", flag.PanicOnError)
	flags.Bool("h", false, "Show help text")
	flags.String("a", "World", "A string to place after 'Hello'")
```

Cookoo uses Go's built-in `flag` package for supporing commandline
flags. If you're not sure how commandline flags work, you may want to
take a look at the Godocs for `flag`.

Simply stated, we declare two flags above:

- `-h`: The help flag. Whenever we override the default flags, we need
  to supply `-h` if we want help support.
- `-a`: This flag allows us to pass a string from the command line into
  our program.

Before we head on to the rest of the program, let's take a look at what
happens when we run our program.

## In Action

First, let's call the program with no arguments:

```
$ go run main.go
Hello World!
```

Yup, it's the old Hello World again. Now let's take a look at the help
text:

```
$ go run main.go -h

SUMMARY
=======

A Hello World program

USAGE
=====

This program writes Hello World to standard output.

With the -a flag, the second word can be replaced by an artitary string.


FLAGS
=====
	-a: A string to place after 'Hello' (Default: 'World')
	-h: Show help text (Default: 'false')
```

Whoa! Now we have an entire help page! Notice that the documentation on
`FLAGS` is completely autogenerated from the `flag.FlagSet`.

Third, let's try out this `-a` flag:

```go
$ go run main.go -a You
Hello You!
```

Passing in `-a You` altered the output from `Hello World!` to `Hello
You!`.

Feel free to try a few experiments before proceeding to the next
section.

## Our Revised Route

In the last chapter we looked at the simple "hello" route. In this
chapter we've made a minor modification:

```go
	reg.Route("hello", "A Hello World route").
		Does(fmt.Printf, "_").
		Using("format").WithDefault("Hello %s!\n").
		Using("0").From("cxt:a")
```

In this example, `Does()` is now getting two arguments:

1. "format" - The formatting string passed into Printf
2. "0" - The first (zero-eth) argument passed into the Printf format
   string

Essentially, we're building something like `fmt.Printf(format, zero)`.

But there's something else going on here. While "format" is still
getting it's default string ("Hello %s!\n"), the `Using("0")` is getting
its data `From("cxt:a")`. What does that mean?

Simply stated, it means that it looks into the Cookoo context for a
value named "a". If it finds that value, it passes it on. This is sort
of equivalent to:

```
fmt.Printf(format, cxt.Get("a", "").(string))
```

Here's where Cookoo starts to get powerful. We can build into the Route
configuration some rules about how to execute a program. The underlying
commands don't have to know anything about our flow logic. And Cookoo
handles the role of mapping state (context) to command execution.

Enough grandiose talk... let's answer a practical question: Where does
"a" come from?

The answer: It comes from the `flag.FlagSet` we defined.

## Running the CLI with a FlagSet and Help Text

Along with changing the route, we also modified the last line of
`main()`:

```go
	cli.New(reg, router, cxt).Help(Summary, Description, flags).Run("hello")
```

We've added one function to our little chain here: `Help(Summary,
Description, flags)`.

This function passes three things to the CLI runner:

- The Summary text
- The Description text
- The flag.FlagSet we created

All three of these are used to generate help text, and the FlagSet is
also used to process commandline flags.

When `Run()` is called, it will use the `FlagSet` to parse the
commandline flags. And it places the values of the flags into the
context.

For that reason, our `-a` flag is now available in the context as `a`.
And that's how `Using("0").From("cxt:a")` fetched the value of `-a` from
the command line.

So we added a flag like this:

```go
	flags.String("a", "World", "A string to place after 'Hello'")
```

And Cookoo interpreted this as "If -a is supplied, use the value given,
otherwise set the value of -a to 'World'".

When `Run("hello")` is called, the arguments are parsed, and "a" is
inserted into the context with either the user-supplied value or (if no
value is passed on the command line) the value "World".

## Good Practices

In this chapter we've seen how to add command line flags and help text.
It is considered standard practice to use `Help()` in *every program* to
create help text and (at minumum) set a `-h` flag.

In the next chapter we'll see how to write CLIs with subcommand support
(like `git` and `go` have).
